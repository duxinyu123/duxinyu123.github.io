---
layout:     post                    # 使用的布局（不需要改）
title:      Python面向对象总结-下篇    # 标题 
subtitle:    						#副标题
date:       2020-12-29              # 时间
author:     新宇                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Python
---
>面向对象三大特性：封装、继承、多态

# 1. 多态
1. 概念：在面向对象的编程思想中，一个类可以创建多个对象，每个对象和属性的行为之间会存在一些差异，编程过程中使用不同的对象，那么有可能得到不同的结果
2. 优点：提高代码灵活性

```
class Dog():
    def work(self):
        print('ready to work!')


class ArmyDog(Dog):
    def work(self):
        Dog.work(self)
        print('开始抓人了！')


class DrugDog(Dog):
    def work(self):
        Dog.work(self)
        print('开始检查毒品！')


class Person():
    def work_with_dog(self, dog):
        dog.work()


# 多态
ad = ArmyDog()
dd = DrugDog()

p = Person()
p.work_with_dog(ad)
p.work_with_dog(dd)

```

# 2. 类属性和实例属性
1. 类属性
	- 类拥有的属性，被该类的所有实例共有；
	- 类属性可以使用类对象和实例对象访问；
	- 类属性只能通过类对象修改，不能通过实例修改
    - 如果通过实例对象修改类属性，表示创建了一个同名实例属性
	- 优点：始终保持一致，并只占用一分内存，更加节省内存空间；


```
class Person():
    # 类属性
    tooth = 10
    # 类私有属性
    __leg = 2

    def print_info(self):
        pass

# 类属性可以使用类对象和实例对象访问；
p = Person()
p1 = Person()
print(Person.tooth)
print(p.tooth)
print(p1.tooth)

# 类属性只能通过类对象修改，不能通过实例修改
Person.tooth = 20

print(Person.tooth)
print(p.tooth)
print(p1.tooth)

# 如果通过实例对象修改类属性，表示创建了一个同名实例属性
p.tooth = 15
print(Person.tooth)
print(p.tooth)
print(p1.tooth)

```


# 3. 类方法和静态方法
1. 类方法： 通过@classmethod装饰器进行装饰的方法，传入的是类对象
	 - 操作类属性/私有类属性方式时才使用
	 - 类对象和实例对象都可以使用


2. 静态方法：通过@staticmethod装饰器进行装饰的方法
	- 形参没有cls/self, 不需要传递类对象和实例对象
	- 减少不必要的内存消耗

3. 类方法 VS 静态方法
	- 定义方式不一样
	- 指定形参不一样
	- 使用场景不一样
	- 类方法修改类属性或者类的其他操作
	- 静态方法不需要对象参与的功能实现
	- 类和实例都可以调用类方法、静态方法和实例方法

```
class Person():
    __leg = 2

    @classmethod
    def get_leg(cls):
        return cls.__leg

    @staticmethod
    def print_info():
        return 'static method'


p = Person()
print(Person.get_leg())
print(p.get_leg())
print(Person.print_info())
print(p.print_info())
```

# 4. 异常
1. 概念：在程序运行过程中报的错误
2. 异常会影响程序后续代码的运行
3. try except 捕获的错误，可以用as为它起别名
4. try except 只能捕获runtime产生的异常

```
try:
    print(num)
except (NameError, ZeroDivisionError) as e:
    print(e)
else:
    print('try未产生异常时，会执行到')
finally:
    print('不管是否出现异常，都会执行到')
```






