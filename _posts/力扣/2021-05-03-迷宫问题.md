---
layout:     post                    # 使用的布局（不需要改）
title:      迷宫问题(一)	        # 标题 
subtitle:   dfs,bfs  	# 副标题
date:       2021-05-03              # 时间
author:     新宇                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               # 标签
    - leetcode
---
# 一、问题介绍
- 在迷宫中有一个球，里面有空的空间和墙壁。球可以通过滚上，下，左或右移动，但它不会停止滚动直到撞到墙上（即每一次滚动到墙才停止然后进行下一次滚动）。当球停止时，它可以选择下一个方向。
给定球的起始位置，目的地和迷宫，确定球是否可以停在终点。
- 迷宫由二维数组表示。1表示墙和0表示空的空间。你可以假设迷宫的边界都是墙。开始和目标坐标用行和列索引表示。
- 难度: 困难

![](https://tva1.sinaimg.cn/large/008i3skNly1gq5ipp0o8rj30iu0c3wf6.jpg)

# 二、代码实现
## 1. 深度优先遍历(递归)
![](https://tva1.sinaimg.cn/large/008i3skNly1gq5n14282gj30to0drn5v.jpg)
![](https://tva1.sinaimg.cn/large/008i3skNly1gq5n299kwoj30u80cgjz9.jpg)

```python
# 定义迷宫矩阵

#metrix = [[0 for i in range(5)] for j in range(5)]

#metrix[0][2]=metrix[2][3]=metrix[3][0]=metrix[3][1]=metrix[3][3]=metrix[3][4]=1

## print(metrix)

metrix = [[0,0,1,0,1], [0,0,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]

# 深度优先遍历

def dfs(i, j, dest):
    if i < 0 or i >= len(metrix) or j < 0 or j >= len(metrix[0]) or metrix[i][j] == 1:
        return False
    row, col = dest
    if i == row and j == col:
        return True
    # 破坏现场，深度遍历不能走回头路

    metrix[i][j] = 1
    # 进行深度优先遍历

    flag = dfs(i-1, j, dest) or dfs(i+1, j, dest) or dfs(i, j-1, dest) or dfs(i, j+1, dest)
    # 复原现场

    metrix[i][j] = 0
    return flag

def maze(start, dest):
    begin_row, begin_col = start
    return dfs(begin_row, begin_col, dest)

print(maze((0,3), (4,4)))

```

## 2. 广度优先遍历(队列)
![](https://tva1.sinaimg.cn/large/008i3skNly1gq5n2lcw5zj30u60czwkg.jpg)
![](https://tva1.sinaimg.cn/large/008i3skNly1gq5n2v6x2uj30th0bfn4y.jpg)
```python
from queue import Queue

# 定义迷宫矩阵

# metrix = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]]

metrix = [[0,0,1,0,1], [0,0,1,1,1], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0]]

def bfs(start, dest):
    begin_row, begin_col = start
    dest_row, dest_col = dest
    q = Queue()
    q.put((begin_row, begin_col))
    # 设置返回结果

    flag = False
    while not q.empty():
        if flag:
            break
        row, col = q.get()
        # 破坏现场:遍历过的置为-1

        metrix[row][col] = -1
        # 进行广度优先遍历

        for (i, j) in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
            if i < 0 or j >= len(metrix) or j < 0 or j >= len(metrix[0]) or metrix[i][j] == 1 or metrix[i][j] == -1:
                continue
            if i == dest_row and j == dest_col:
                flag = True
            q.put((i, j))
        # 还原现场

        metrix[row][col] = 0

    metrix[begin_row][begin_col] = 0
    return flag

print(bfs((0, 3), (3, 2)))
```
