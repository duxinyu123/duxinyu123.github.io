---
layout:     post                    # 使用的布局（不需要改）
title:      排序算法    				# 标题 
subtitle:    						#副标题
date:       2021-01-16              # 时间
author:     新宇                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 数据结构&算法
---

# 一、排序算法的稳定性
# 1. 概念
![](https://tva1.sinaimg.cn/large/008eGmZEly1gmpaffcbkyj31aq0iuagn.jpg)

例如：如果订单默认按照时间排序，需要按照金额排序，就要保证相同金额的订单原来的时间顺序不会变化；

## 2. 不稳定排序
选择 快速 希尔 堆

## 3. 稳定排序
冒泡 插入 归并 基数

## 4. 衡量标准
- 时间复杂度：最好/最坏
- 空间复杂度：原地排序（O(1)）

# 二、冒泡排序
## 1. 定义
![](https://tva1.sinaimg.cn/large/008eGmZEly1gmpasvqggjj31bm0kc7e6.jpg)
![](https://pic3.zhimg.com/50/v2-62b35f38b9806cb2e50c7e4ee0ec3386_hd.webp?source=1940ef5c)

## 2.代码实现
```python
def bubble_sort(l):
    n = len(l)
    # 外层循环控制轮数
    
    for i in range(n-1):
        count = 0
        # 内层循环控制每轮比较的次数
        
        for j in range(n-1-i):
            if l[j] > l[j+1]:
                count += 1
                l[j], l[j+1] = l[j+1], l[j]
    print(l)

bubble_sort([6,5,4,3,2,1])
```
## 3.效率分析

1. 时间复杂度
	 - 最好：O(n)
	 - 最坏：O(n2)

2. 稳定性：稳定算法

3. 空间复杂度：O(1), 为原地排序

# 三、选择排序
## 1. 定义
![](https://tva1.sinaimg.cn/large/008eGmZEly1gmpdlom904j31140j6gwa.jpg)
![](https://pic1.zhimg.com/50/v2-c5e176ffc200c8f4f137e732fe860b60_hd.webp?source=1940ef5c)

## 2. 代码实现

```python 
def select_sort(l):
    n = len(l)
    # 第一层循环控制迭代轮数
    
    for i in range(0, n-1):
        mix_index = i
        # 第二层循环控制比较次数
        
        for j in range(i+1, n):
            if l[mix_index] > l[j]:
                mix_index = j
        if mix_index != i:
            l[mix_index], l[i] = l[i], l[mix_index]
    print(l)

select_sort([1,2,3,6,5,4])
```

## 3. 效率分析
1. 时间复杂度： 最好O(n2) 最坏O(n2)
2. 稳定性：不稳定算法，例如5 8 5 2（因算法而异）
3. 空间复杂度：O(1), 为原地排序

# 三、插入排序
## 1. 定义
![](https://tva1.sinaimg.cn/large/008eGmZEly1gmpjvkakj9j31ao0mg16s.jpg)
![](https://pic1.zhimg.com/50/v2-38d6f9c006e3fdb24ffd82a58c39ca92_hd.webp?source=1940ef5c)

## 2. 代码实现
```python
def insert_sort(l):
    n = len(l)
    # 第一层循环控制轮数

    for i in range(1, n):
        # 第二层循环控制每一轮比较次数
        
        for j in range(i, 0, -1):
            if l[j] < l[j-1]:
                l[j], l[j-1] = l[j-1], l[j]
            else:
                break
    print(l)

insert_sort([6,5,4,3,2,1])
```

## 3. 效率分析
1. 时间复杂度：最好 O(n) 最坏 O(n2)
2. 空间复杂度：O(1)
3. 稳定性：稳定


