---
layout:     post                    # 使用的布局（不需要改）
title:      机器学习基础(三)    				# 标题 		  
subtitle:   Numpy、Pandas	 		#副标题
date:       2021-01-25              # 时间
author:     新宇                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 机器学习
---

# 一、Numpy
## 1. 概念
- Numpy(Numerical Python)是一个开源的Python科学计算库，用于快速处理任意维度的数组。 
- Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。 
- Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。

## 2. ndarray介绍
### 1. 概念
NumPy提供了一个N维数组类型ndarray，它描述了相同类型的“items”的集合。

### 2. ndarray与Python原生list运算效率对比

```python
import random 
import time 
import numpy as np 

a = []
for i in range(100000000): 
    a.append(random.random())
# 通过%time魔法方法, 查看当前行的代码运行一次所花费的时间 

%time sum1=sum(a)
b=np.array(a)
%time sum2=np.sum(b)

## 结果对比:

# CPU times: user 831 ms, sys: 1.8 s, total: 2.63 s

# Wall time: 2.74 s

# CPU times: user 56.3 ms, sys: 335 µs, total: 56.6 ms

# Wall time: 56.4 ms

```

### 3. ndarray原理
1. **内存模型**
	![](https://tva1.sinaimg.cn/large/008eGmZEly1gn03i7l74nj30kf0byjvr.jpg)
2. **支持并行化运算**：numpy内置了并行运算功能，当系统有多个核心时，做某种计算时，numpy会自动做并行计算
3. **效率远高于纯Python代码**：Numpy底层使用C语言编写，内部**解除了GIL**(全局解释器锁)，其对数组的操作速度不受Python解释器的限制，所以，其效率远高于纯Python代码。


### 4. ndarray属性介绍
![](https://tva1.sinaimg.cn/large/008eGmZEly1gn03m7gr9qj30k704n0t0.jpg)

### 5. ndarray的类型
![](https://tva1.sinaimg.cn/large/008eGmZEly1gn03og84hqj30k30cymyv.jpg)

### 6. 代码
```python
# 创建数组时指定类型
a = np.array([[1, 2, 3],[4, 5, 6]], dtype=np.float32) >>> a.dtype

arr = np.array(['python', 'tensorflow', 'scikit-learn', 'numpy'], dtype = np.string_) 
```
## 3. numpy快速创建数组

### 1. 生成0和1的数组
- np.ones(shape, dtype)
- np.ones_like(a, dtype)
- np.zeros(shape, dtype)
- np.zeros_like(a, dtype)

### 2. 从现有数组生成
- 从现有数组生成
	- 深拷贝：np.array(object, dtype) 
	- 赋值：np.asarray(a, dtype)
- 生成固定范围的数组
	- 创建等差数组 — 指定数量： np.linspace (start, stop, num, endpoint)
	- 创建等差数组 — 指定步长：np.arange(start,stop, step, dtype)
	- 创建等比数列：np.logspace(start,stop, num)

## 4. 生成随机数组
> np.random模块

### 1. 正态分布
1. 概念：正态分布是一种概率分布。正态分布是具有两个参数μ和σ的连续型随机变量的分布，第一参数μ是服从正态分布的随机变量的均值，第二个参数σ是此随机变量的标准差，所以正态分布记作N(μ，σ)。
	![](https://tva1.sinaimg.cn/large/008eGmZEly1gn1fl6dg9dj30oq0gj43d.jpg)

2. 创建方式： 
	- 标准正态分布： np.random.randn(d0, d1, ..., dn)
	- 指定正态分布：np.random.normal(loc=0.0, scale=1.0, size=None)
	- 指定形状的标准正态分布：np.random.standard_normal(size=None)

3. 代码

	```python
	# 生成均值为1.75，标准差为1的正态分布数据，100000000个

	x1 = np.random.normal(1.75, 1, 100000000)

	# 生成均匀分布的随机数

	x1 = np.random.normal(1.75, 1, 100000000)
	# 画图看分布状况

	# 1)创建画布

	plt.figure(figsize=(20, 10), dpi=100)
	# 2)绘制直方图 

	plt.hist(x1, 1000)
	# 3)显示图像 

	plt.show()
	```


### 2. 均匀分布
1. 创建方式
	- 返回[0.0，1.0)内的一组均匀分布的数: 
		- np.random.rand(d0, d1, ..., dn) 
	- 一个均匀分布[low,high)中随机采样: 
		- np.random.uniform(low=0.0, high=1.0, size=None)
	- 一个均匀分布中随机采样，生成一个整数或N维整数数组: 
		- np.random.randint(low, high=None, size=None, dtype='l')
2. 代码

	```python
	x2 = np.random.uniform(0,10,1000000)
	plt.figure(figsize=(20,8), dpi=100)
	# x代表要使用的数据，bins表示要划分区间数

	plt.hist(x2,bins=1000)
	plt.show()
	```


### 3. 数组的索引、切片
1. 一维、二维、三维的数组如何索引?
	- 直接进行索引,切片 
	- 对象[:, :] -- 先行后列

2. 代码

	```python
	stock_change[0,0:3]
	```

### 4. 形状修改
- 返回一个具有相同数据域，但shape不一样的视图:
	- ndarray.reshape(shape, order)
- 修改数组本身的形状(需要保持元素个数前后相同):
	- ndarray.resize(new_shape)
- 数组的转置
	- ndarray.T
	- ndarray.transpose()

### 5. 类型修改
- 返回修改了类型之后的数组
	- ndarray.astype(type)
- 构造包含数组中原始数据字节的Python字节
	- ndarray.tostring([order])
	- ndarray.tobytes([order])

### 6. 数组的去重
- np.unique()

```python
temp = np.array([[1, 2, 3, 4],[3, 4, 5, 6]])
# >>> np.unique(temp)

array([1, 2, 3, 4, 5, 6])
```


## 5. ndarray运算
### 1. 逻辑运算
```python
 # 生成10名同学，5门功课的数据

>>> score = np.random.randint(40, 100, (10, 5))
# 取出最后4名同学的成绩，用于逻辑判断 

>>> test_score = score[6:, 0:5]
# 逻辑判断, 如果成绩大于60就标记为True 否则为False

>>> test_score > 60
array([[ True, True, True, False, True],
[ True, True, True, False, True], [ True, True, False, False, True], [False, True, True, True, True]])
# BOOL赋值, 将满足条件的设置为指定的值-布尔索引 

>>> test_score[test_score > 60] = 1
>>> test_score
array([[ 1, 1, 1, 52, 1],
[1, 1, 1,59, 1], [ 1, 1, 44, 44, 1], [59, 1, 1, 1, 1]])
```
### 2. 通用判断函数
```python
# 判断前两名同学的成绩[0:2, :]是否全及格 

np.all(score[0:2, :] > 60)
False
# 判断前两名同学的成绩[0:2, :]是否有大于90分的 

np.any(score[0:2, :] > 80)
True
```

### 3. np.where(三元运算符)
```python
# 判断前四名学生,前四门课程中，成绩中大于60的置为1，否则为0 

temp = score[:4, :4]
np.where(temp > 60, 1, 0)

# 复合逻辑需要结合np.logical_and和np.logical_or使用

# 判断前四名学生,前四门课程中，成绩中大于60且小于90的换为1，否则为0 

 np.where(np.logical_and(temp > 60, temp < 90), 1, 0)
# 判断前四名学生,前四门课程中，成绩中大于90或小于60的换为1，否则为0 

np.where(np.logical_or(temp > 90, temp < 60), 1, 0)
```

### 4. 统计运算
- min(a, axis)
- max(a, axis])
- median(a, axis)
	- 求中位数
- mean(a, axis, dtype)
	- 求平均数
- std(a, axis, dtype)
	- 标准差
- var(a, axis, dtype)
	- 方差
- argmax() 
	- 返回最大值所在的索引
- argmin()
	- 返回最小值所在的索引

```python
# 接下来对于前四名学生,进行一些统计运算

# 指定列 去统计

temp = score[:4, 0:5] 
print("前四名学生,各科成绩的最大分:{}".format(np.max(temp, axis=0))) 
print("前四名学生,各科成绩的最小分:{}".format(np.min(temp, axis=0))) 
print("前四名学生,各科成绩波动情况:{}".format(np.std(temp, axis=0))) 
print("前四名学生,各科成绩的平均分:{}".format(np.mean(temp, axis=0)))
```
## 6. 数组间运算
### 1. 数组与数的运算
```python
arr = np.array([[1, 2, 3, 2, 1, 4], [5, 6, 1, 2, 3, 1]]) 
arr + 1
arr / 2
# 可以对比python列表的运算，看出区别 a = [1, 2, 3, 4, 5]

a*3
```

### 2. 数组与数组的运算

1. **广播机制**：数组在进行矢量化运算时，要求数组的形状是相等的。当形状不相等的数组执行算术运算的时候，就会出现广播机制，该机制会对数组进行扩展，使数组的shape属性值一样，这样，就可以进行矢量化运算了。满足以下任意一个条件即可：
	- 如果两个数组的后缘维度(trailing dimension，即从末尾开始算起的维度)的轴长度相符
	- 或其中的一方的长度为1。

2. 代码
	```python
	 arr1 = np.array([[0],[1],[2],[3]]) arr1.shape
	# (4, 1)

	arr2 = np.array([1,2,3]) arr2.shape
	# (3,)

	arr1+arr2
	# 结果是: array([[1, 2, 3],

	[2, 3, 4],
	[3, 4, 5],
	[4, 5, 6]])
	```

3. ![](https://tva1.sinaimg.cn/large/008eGmZEly1gn1gifh9whj30n50acdo1.jpg)


## 7. 矩阵运算
> 这部分只介绍乘法API：np.matmul 和 np.dot

1. np.matmul和np.dot的区别:
二者都是矩阵乘法。 np.matmul中禁止矩阵与标量的乘法。 在矢量乘矢量的內积运算中，np.matmul与np.dot没有区别。

2. 代码
	```python
	 >>> a = np.array([[80, 86], [82, 80],
	[85, 78],
	[90, 90],
	[86, 82],
	[82, 90],
	[78, 80],
	[92, 94]])
	>>> b = np.array([[0.7], [0.3]])
	>>> np.matmul(a, b) 
	array([[81.8],
	[81.4], [82.9], [90. ], [84.8], [84.4], [78.6], [92.6]])
	>>> np.dot(a,b) 
	array([[81.8], [81.4], [82.9], [90. ], [84.8], [84.4], [78.6],
	                   [92.6]])
	```

# 二、Pandas
## 1. 介绍
![](https://tva1.sinaimg.cn/large/008eGmZEly1gn1glodg4hj30ml07s772.jpg)
## 2. Pandas的优势
- 增强图表可读性
- 便捷的数据处理能力
- 读取文件方便
- 封装了Matplotlib、Numpy的画图和计算

## 3. Pandas数据结构
### 1. Series
1. Series是一个类似于一维数组的数据结构，它能够保存任何类型的数据，比如整数、字符串、浮点数等，主要由一组数据和与之相关的索引两 部分构成。

2. 代码
	```python
	pd.Series([6.7,5.6,3,10,2], index=[1,2,3,4,5])

	# Series的属性：index和values

	color_count.index
	# 结果

	Index(['blue', 'green', 'red', 'yellow'], dtype='object')

	color_count.values
	# 结果

	array([ 200, 500, 100, 1000])

	color_count[2]
	# 结果 

	100
	 
	```


### 2. DataFrame
![](https://tva1.sinaimg.cn/large/008eGmZEly1gn1gt1cdkyj30em0asq4r.jpg)

1. DataFrame是一个类似于二维数组或表格(如excel)的对象，既有行索引，又有列索引；
	- 行索引，表明不同行，横向索引，叫index，0轴，axis=0
	- 列索引，表名不同列，纵向索引，叫columns，1轴，axis=1

2. 代码
	```python
	 # 生成10名同学，5门功课的数据

	score = np.random.randint(40, 100, (10, 5))

	# 使用Pandas中的数据结构 

	score_df = pd.DataFrame(score)

	# 构造行索引序列

	subjects = ["语文", "数学", "英语", "政治", "体育"]
	# 构造列索引序列

	stu = ['同学' + str(i) for i in range(score_df.shape[0])]
	# 添加行索引

	data = pd.DataFrame(score, columns=subjects, index=stu)

	```

3. 属性
	```python
	# DataFrame的属性: 

	# DataFrame的行索引列表

	data.index
	# DataFrame的列索引列表

	data.columns
	# 直接获取其中array的值
	
	data.value
	# 转置

	data.T
	# 显示前5行内容

	data.head(5)
	# 显示前5行内容

	data.tail(5)
	```

4. DatatFrame索引的设置
	```python
	stu = ["学生_" + str(i) for i in range(score_df.shape[0])]
	# 必须整体全部修改 

	data.index = stu

	# 重设索引 eset_index(drop=False)

	# 默认为False，不删除原来索引，如果为True,删除原来的索引值

	data.reset_index(drop=True)
	```

5. 以某列值设置为新的索引
	```python
	# et_index(keys, drop=True)

	# keys : 列索引名成或者列索引名称的列表

	# drop : boolean, default True.当做新的索引，删除原来的列
	
	df = pd.DataFrame({'month': [1, 4, 7, 10],'year': [2012, 2014, 2013, 2014],'sale':[55, 40, 84, 31]})

	df.set_index('month')
	# 设置多个索引，以年和月份(变成了一个具有MultiIndex的DataFrame)

	df = df.set_index(['year', 'month']
	```


### 3. MultiIndex
1. MultiIndex是三维的数据结构; 多级索引(也称层次化索引是pandas的重要功能，可以在Series、DataFrame对象上拥有2个以及2个以上的索引。

2. 代码
	```python
	df.index
	# 输出：

	MultiIndex(levels=[[2012, 2013, 2014], [1, 4, 7, 10]], labels=[[0, 2, 1, 2], [0, 1, 2, 3]],
	names=['year', 'month'])

	# names:levels的名称

	df.index.names
	# FrozenList(['year', 'month'])

	# levels:每个level的元组值

	df.index.levels
	# FrozenList([[1, 2], [1, 4, 7, 10]])
   

   	# multiIndex的创建
   	arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']] 
   	pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))

	```


### 4. Panel(已弃用)

## 4. Pandas高级操作
### 1. 索引
```python
# 不支持操作

data[:3,:2]
# 错误操作: 必须先列后行

data['2018-02-27']['open']
# 正确：先列后行

data['open']['2018-02-27']

# loc 与 iloc， loc 使用索引名, iloc 使用索引下标, 此处都是先行后列, 左闭右闭
data.loc[:'2018-02-23', 'open':'low']
data.iloc[:3, :2]

# ix混合索引, 即将废弃，不建议使用

data.ix[:'2018-02-23', :2]

# 混合索引：通过 loc 获取的方式

data.loc[data.index[0:4], 'open':'low']

# 混合索引：通过 iloc 获取的方式 

data.iloc[0:4, data.columns.get_indexer(['open','low'])]

```

### 2. 赋值操作
```python
# 对列进行赋值, 直接对原来的值进行修改

data.high = 10
data['high'] = 1
```

### 3. 排序
```python
# 排序有两种形式，一种对于索引进行排序，一种对于内容进行排序

# 对索引进行排序 axis=0 行索引排序，axis=1 列索引排序

data.sort_index(axis=1).head() 

# 对于内容进行排序 , ascending 是否升序排列

data['open'].sort_values(ascending=False).head()
```

### 4. 运算
1. 加减法运算

	```python
	# 比如进行数学运算加上具体的一个数字

	data['open'].add(10).head()
	# 减法运算

	data['open'].sub(10).head()
	```

2. 逻辑运算

	```python
	#  & 与, ｜ 或

	data[(data["open"] > 23.19) & (data["open"] < 23.21)].head()
	```


3. 统计运算
	![](https://tva1.sinaimg.cn/large/008eGmZEly1gn3cmur7dqj30lg0awmy7.jpg)
	![](https://tva1.sinaimg.cn/large/008eGmZEly1gn3comggwgj30lc053aad.jpg)
	```python
	# 综合分析: 能够直接得出很多统计结果, count , mean , std , min , max 等

	data.describe()


	# 使用统计函数: 0 代表列求结果， 1 代表行求统计结果

	data.max(0)

	# 求中位数 ,分两步： 1 先对列进行排序 2 找中间值，如果有两个则取平均数

	df.median(0)

	# idxmax()/ idxmin(): 求出最大/小值的位置

	data.idxmax(axis=0)

	# 累计统计函数 cumsum()

	stock_rise = data['p_change']
	stock_rise.head()
	stock_rise.cumsum()
	# 使用pandas绘图

	stock_rise.cumsum().plot()
	plt.show()


	# 自定义运算

	data[['open', 'close']].apply(lambda x: x.max() - x.min(), axis=1)
	```






